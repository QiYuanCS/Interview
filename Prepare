C语言实现：有一个指针指向字符串首地址，字符串由一堆数字组成，数字之间用逗号隔开，用一种最快的方法将最大的数与第一个数交换，最小的数与最后一个数交换。（注意数字可能不止一位）

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Function to swap two integers
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Function to find the maximum and minimum in an array and swap values
void processString(char *str) {
    int numbers[100]; // Assuming the string has at most 100 numbers
    int count = 0;    // Count of numbers in the array
    
    // Parse the string into numbers
    char *token = strtok(str, ",");
    while (token != NULL) {
        numbers[count++] = atoi(token); // Convert string to integer
        token = strtok(NULL, ",");
    }

    // Find the indices of the maximum and minimum values
    int maxIdx = 0, minIdx = 0;
    for (int i = 1; i < count; i++) {
        if (numbers[i] > numbers[maxIdx]) {
            maxIdx = i;
        }
        if (numbers[i] < numbers[minIdx]) {
            minIdx = i;
        }
    }

    // Swap the maximum with the first element
    if (maxIdx != 0) {
        swap(&numbers[0], &numbers[maxIdx]);
    }

    // Swap the minimum with the last element
    if (minIdx != count - 1) {
        swap(&numbers[count - 1], &numbers[minIdx]);
    }

    // Reconstruct the string
    printf("Processed string: ");
    for (int i = 0; i < count; i++) {
        if (i > 0) {
            printf(",");
        }
        printf("%d", numbers[i]);
    }
    printf("\n");
}

// Main function to test the implementation
int main() {
    char input[] = "3,5,1,9,2"; // Example input
    printf("Original string: %s\n", input);

    processString(input);

    return 0;
}



找出二维数组中的最大数并输出，使用指针运算。并指出第6个数是什么。

#include <stdio.h>

void findMaxAndSixth(int rows, int cols, int arr[rows][cols]) {
    int *ptr = &arr[0][0]; // 指向数组首地址
    int max = *ptr;        // 初始化最大值为第一个数
    int sixthNumber = 0;   // 存储第 6 个数
    int totalElements = rows * cols;

    // 遍历数组
    for (int i = 0; i < totalElements; i++) {
        if (*(ptr + i) > max) {
            max = *(ptr + i); // 更新最大值
        }
        // 如果是第 6 个数
        if (i == 5) {
            sixthNumber = *(ptr + i);
        }
    }

    // 输出结果
    printf("The maximum number in the array is: %d\n", max);
    printf("The 6th number in the array is: %d\n", sixthNumber);
}

int main() {
    // 定义一个示例二维数组
    int array[3][4] = {
        {3, 8, 12, 7},
        {5, 15, 20, 11},
        {6, 13, 10, 9}
    };

    // 输出数组
    printf("Array:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", array[i][j]);
        }
        printf("\n");
    }

    // 调用函数
    findMaxAndSixth(3, 4, array);

    return 0;
}

#include <stdio.h>

void findMaxAndSixth(int rows, int cols, int (*arr)[cols]) {
    int max = **arr;      // 初始化最大值为数组第一个元素
    int sixthNumber = 0;  // 第 6 个数存储
    int count = 0;        // 元素计数器

    // 遍历二维数组
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            int *current = *(arr + i) + j; // 获取当前元素指针
            if (*current > max) {
                max = *current; // 更新最大值
            }
            count++;
            if (count == 6) {
                sixthNumber = *current; // 保存第 6 个数
            }
        }
    }

    // 输出结果
    printf("The maximum number in the array is: %d\n", max);
    printf("The 6th number in the array is: %d\n", sixthNumber);
}

int main() {
    // 定义一个示例二维数组
    int array[3][4] = {
        {3, 8, 12, 7},
        {5, 15, 20, 11},
        {6, 13, 10, 9}
    };

    // 输出数组
    printf("Array:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", array[i][j]);
        }
        printf("\n");
    }

    // 调用函数
    findMaxAndSixth(3, 4, array);

    return 0;
}

有一个uint16_t readPin()函数获取一个uint16_t数，从中提取port0（0-3位）、port1（4-7位）、port2（8-11位、port3（12-15位），并根据表格将port与pin匹配，输出对应的端口名。

数据格式：
假设 uint16_t 的数据格式如下（每 4 位一个端口）：
| port3 (12-15) | port2 (8-11) | port1 (4-7) | port0 (0-3) |
功能需求：
提取每个 port 的值（4 位），即通过位运算提取 port0 到 port3。
根据给定表格（示例数据）输出 port 和 pin 的对应关系。
实现方法：
使用掩码和移位操作提取各部分。
定义一个表格（或数组）存储端口与引脚名的映射关系。

#include <stdio.h>
#include <stdint.h>

// 表格：端口与引脚名映射
const char *portNames[] = {"PortA", "PortB", "PortC", "PortD", "PortE", "PortF", "PortG", "PortH",
                           "PortI", "PortJ", "PortK", "PortL", "PortM", "PortN", "PortO", "PortP"};

// 从 uint16_t 数据中提取端口信息并输出
void processPinData(uint16_t data) {
    uint8_t port0 = data & 0xF;          // 提取 0-3 位
    uint8_t port1 = (data >> 4) & 0xF;  // 提取 4-7 位
    uint8_t port2 = (data >> 8) & 0xF;  // 提取 8-11 位
    uint8_t port3 = (data >> 12) & 0xF; // 提取 12-15 位

    // 输出结果
    printf("Extracted Ports:\n");
    printf("Port0 (0-3): %s (Pin %d)\n", portNames[port0], port0);
    printf("Port1 (4-7): %s (Pin %d)\n", portNames[port1], port1);
    printf("Port2 (8-11): %s (Pin %d)\n", portNames[port2], port2);
    printf("Port3 (12-15): %s (Pin %d)\n", portNames[port3], port3);
}

// 模拟 readPin 函数
uint16_t readPin() {
    return 0xABCD; // 示例数据，实际值应由硬件读取
}

int main() {
    // 读取数据
    uint16_t pinData = readPin();
    printf("Read Data: 0x%04X\n", pinData);

    // 处理数据
    processPinData(pinData);

    return 0;
}

提取各部分：
data & 0xF 提取 port0（最低 4 位）。
(data >> 4) & 0xF 提取 port1（移位并掩码）。
(data >> 8) & 0xF 提取 port2。
(data >> 12) & 0xF 提取 port3。
映射关系：
使用 portNames 数组存储端口名，数组索引对应位段值。
输出结果：
根据提取的位段值，输出端口名及引脚编号。

#include <stdio.h>
#include <ctype.h>
#include <string.h>

void convertTwiceToUpper(char *str) {
    int charCount[26] = {0}; // 用于记录每个小写字母的出现次数
    int i;

    // 遍历字符串，统计每个字符的出现次数
    for (i = 0; str[i] != '\0'; i++) {
        if (str[i] >= 'a' && str[i] <= 'z') {
            charCount[str[i] - 'a']++;
        }
    }

    // 再次遍历字符串，把出现两次的字符转换为大写
    for (i = 0; str[i] != '\0'; i++) {
        if (charCount[str[i] - 'a'] == 2) {
            str[i] = toupper(str[i]);
        }
    }
}

int main() {
    char str[] = "abcdeabcdeffggh";
    printf("原始字符串: %s\n", str);
    convertTwiceToUpper(str);
    printf("转换后字符串: %s\n", str);
    return 0;
}
